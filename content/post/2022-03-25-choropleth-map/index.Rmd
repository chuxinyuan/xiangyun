---
title: 专题地图及其应用
author: 黄湘云
date: '2022-03-25'
slug: choropleth-map
categories:
  - 统计图形
tags: 
  - 专题地图
  - 制图学
  - 地理可视化
  - ggplot2
  - sf
  - tmap
  - mapsf
  - lattice
  - latticeExtra
  - maps
  - mapproj
  - usmapdata
  - showtext
  - tidycensus
draft: true
link-citations: true
bibliography: 
  - refer.bib
toc: true
description: "专题地图应用广泛，特别是展示统计年鉴数据。笔者从美国和日本国家统计局官网发现存在大量专题地图用于展示各类指标，衡量一个部门、一个业务、一个公司、一个行业，乃至一个国家都有一套金字塔式的指标体系，而国家每年发布的统计年鉴就是衡量国家经营状态的指标体系，涵盖人口、土地、生产、消费等专题，省、市、区县以及自治区等各级地方统计局每年也会发布一份地方统计年鉴。"
---


```{css, echo=FALSE}
.sidebar {
  border: 1px solid #ccc;
}

.rmdwarn {
  border: 1px solid #EA4335;
}

.rmdnote {
  border: 1px solid #FBBC05;
}

.rmdtip {
  border: 1px solid #34A853;
}

.sidebar, .rmdwarn, .rmdnote, .rmdtip {
  border-left-width: 5px;
  border-radius: 5px;
  padding: 1em;
  margin: 1em 0;
}

div.rmdwarn::before, div.rmdnote::before, div.rmdtip::before {
  display: block;
  font-size: 1.1em;
  font-weight: bold;
  margin-bottom: 0.25em;
}

div.rmdwarn::before {
  content: "警告";
  color: #EA4335;
}

div.rmdnote::before {
  content: "注意";
  color: #FBBC05;
}

div.rmdtip::before {
  content: "提示";
  color: #34A853;
}

.rmdinfo {
  border: 1px solid #ccc;
  border-left-width: 5px;
  border-radius: 5px;
  padding: 1em;
  margin: 1em 0;
}
div.rmdinfo::before {
  content: "声明";
  color: block;
  display: block;
  font-size: 1.1em;
  font-weight: bold;
  margin-bottom: 0.25em;
}

figure {
  text-align: center;
}

div.img {
  text-align: center;
  display: block; 
  margin-left: auto; 
  margin-right: auto;
}
```

::: rmdinfo
本文引用的所有信息均为公开信息，仅代表作者本人观点，与就职单位无关。
:::

```{r setup}
#| echo=FALSE

knitr::opts_chunk$set(
  comment = "#",
  message = FALSE,
    error = FALSE,
     tidy = FALSE,
    cache = FALSE,
 collapse = TRUE
)
```


# 本文概览


专题地图应用广泛，特别是展示统计年鉴数据。笔者从美国和日本国家统计局官网发现存在大量专题地图用于展示各类指标，衡量一个部门、一个业务、一个公司、一个行业，乃至一个国家都有一套金字塔式的指标体系，而国家每年发布的统计年鉴就是衡量国家经营状态的指标体系，涵盖人口、土地、生产、消费等专题，省、市、区县以及自治区、州、县等各级地方统计局每年也会发布一份地方统计年鉴。


接下来，本文分四个部分展开介绍专题地图，分别是单变量情形、多变量情形、应用案例和本文小结。


单变量情形中先以 R 软件内置的数据集 state.x77 为例展示 1975 年美国**各个州**每平方英里的人口数，即以专题地图形式展示各州人口密度，此处专题的含义是「人口」，显而易见，人口密度只是一方面，还有人口结构，结构又可以分性别、年龄、种族等等。接着，以 **maps** 包内置的数据集 unemp 数据集为例展示 2009 年美国**各个城镇**的失业率。这样，从州到城镇，专题地图的介绍就覆盖了常见情形。


进一步，以 **latticeExtra** 包内置的数据集 USCancerRates 为例，介绍美国 1999-2003 年度各个城镇的年平均癌症死亡率。这将在数据操作、指标计算和分面绘图等方面提升一倍的复杂度，逐步解剖从零开始绘制专题地图的过程。将更加深入地介绍涉及的基础数据操作，详细比较五个绘图工具 **latticeExtra** 包、**ggplot2** 包、**tmap** 包、**sf** 包和 **mapsf** 包，详细阐述数据指标「年平均癌症死亡率」的实际含义、指标口径和计算过程，从易到难，层层深入，以期达到出版级的水准，探索出最佳实践。


多变量情形中以美国人口统计局发布的调查数据为基础，分析北卡罗来纳州各区县普查粒度的收入与种族的空间相关性。先分别以单变量的专题地图描述各个普查区域里家庭收入中位数、白人占比的空间分布，接着和二元变量的专题地图形成对比，展示相关性的空间分布。


本文小结围绕数据获取、数据操作、度量指标、统计分析、数据展示等方面展开总结和讨论。尽量寻求来源权威可靠的第一手材料，对手头现有的材料有追根溯源和交叉验证的热情。数据操作的过程应满足可重复性的基本要求，以便检查分析过程和结论。度量指标需要围绕专题分析的目标，并结合实际背景选择合适的维度拆解。借助统计工具分析隐藏数据中的深层规律，科学定量地刻画，并将规律用领域语言表达，最后，结合软件工具选用恰当的图形准确呈现，直观定性地表达降低沟通成本，快速形成决策建议，落地推广。


<!-- 
后续各个小节，具体地详细阐述，可能遇到的问题，解决办法，一些具体的经验，建议。

统计分析的基本工具：离散空间相关性度量，连续空间波动程度的度量。

多变量情形，添加中国城镇化率。

改革开放40多年，最显著的变化就是城市化，大量人口进城，围绕吃穿住行，房地产行业，互联网行业，餐饮外卖行业，新零售行业，出行行业，教育培训行业，以及休闲娱乐行业，互联网在各行各业渗透，大数据、互联网、人工智能等技术极大地推动智慧城市规划和建设。「以经济建设为中心」一百年不动摇，必将在下一个四十年为城市发展持续注入动力。

这就是最大的因，因果推断技术本质是从因推断果，而不是相反。围绕此核心分析总体概况，从时间（趋势）、空间（地域）两个维度，拆解分析人、行业。

结合 Apple 金融决策支持岗位的要求[Apple Finance](https://jobs.apple.com/en-us/details/200311967/data-scientist-apple-finance-r-shiny)，此文工作的意义是非常明确的，对个人提升是非常有帮助的。
-->


# 单变量情形

以 state.x77 数据集一步步实现，介绍过程细节。

再进一步，青出于蓝，以美国各个城镇的癌症死亡率分布为例，介绍更加复杂的场景

lattice ggplot2 sf 三个绘图工具，代表三种绘图的思考方式。

介绍[Choropleth map](https://en.wikipedia.org/wiki/Choropleth_map)



## 美国各州的人口密度分布


state.x77 数据集中 Population 州人口数据是 1977 年美国人口调查局发布的统计数据，单位是 1000 人，统计的是 1975 年的人口数据，原始数据可以从官网发布的年度报告[Statistical Abstract of the United States: 1977](https://www.census.gov/library/publications/1977/compendia/statab/98ed.html)获取。


### maps

```{r}
library(maps)
# maps 包地图数据集
list.files(path = system.file("mapdata", package = "maps"))
```


### ggplot2


```{r usa-states-density-ggplot2}
#| fig.cap="1975 年美国各州人口密度，单位每平方英里人口数",
#| fig.width=7,
#| fig.height=5,
#| fig.align="center",
#| fig.showtext=TRUE

# 准备数据
state_x77 <- data.frame(state = rownames(state.x77), state.x77)
state_map <- usmapdata::us_map("states")
state_df <- merge(state_map, state_x77, by.x = "full", by.y = "state", all.x = T)
state_df <- state_df[order(state_df$order), ]
# 绘制地图
library(ggplot2)
ggplot() +
  geom_polygon(
    data = state_df, aes(x, y, group = group, fill = 1000 * Population / Area),
    colour = "gray", size = 0.3
  ) +
  scale_fill_viridis_c(trans = "log10", option = "plasma", na.value = "grey80") +
  labs(
    fill = "人口密度", title = "1975 年美国各州人口密度",
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```


先将地图数据放左边，观测数据放右边，以 LEFT JOIN （左关联） 的方式关联起来，接着对相关原子和衍生指标做一些必要转化计算，最后调用绘图函数绘制专题地图。


### latticeExtra





### sf


```{r usa-states-density-sf}
#| fig.cap="1975 年美国各州人口密度，单位每平方英里人口数",
#| fig.width=7,
#| fig.height=4,
#| fig.align="center",
#| fig.showtext=TRUE,
#| message=FALSE

library(sf)
us_states_shifted <- readRDS(file = "data/us_states_shifted.rds")
us_states <- merge(us_states_shifted, state_x77, by.x = "NAME", by.y = "state", all.x = TRUE)
us_states <- within(us_states, { den <- 1000 * Population / Area })
plot(us_states["den"], logz = TRUE, border = "gray", 
  pal = viridisLite::plasma, nbreaks = 12,
  reset = FALSE, main = "1975 年美国各州人口密度"
)
mtext(text = "数据源：美国人口调查局", side = 1, adj = 0)
```

### ggplot2 + sf

```{r usa-states-density-ggplot2-sf}
#| fig.cap="1975 年美国各州人口密度，单位每平方英里人口数",
#| fig.width=7,
#| fig.height=4,
#| fig.align="center",
#| fig.showtext=TRUE

ggplot() +
  geom_sf(data = us_states, aes(fill = den)) +
  scale_fill_viridis_c(trans = "log10", option = "plasma", na.value = "grey80") +
  labs(
    fill = "人口密度", title = "1975 年美国各州人口密度",
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```


### ggplot2 + ggspatial

**ggspatial** [@Dewey2021]

### tmap



### mapsf



除了州，还有城镇，甚至人口普查单元粒度的地区分布图，以描述更加详细点的空间分布，


接下来，将详细介绍 R 语言在绘制地区分布图中的探索和实践，主要围绕 R 语言社区比较成熟的两套绘图工具 **lattice** 和 **ggplot2** 展开。空间地理可视化的内容非常丰富，笔者所知十分有限，仅以地区分布图为例，读者可取其共性迁移至其它绘图场景。


## 美国各个城镇的失业率分布


以 2009 年美国各个城镇的失业率数据为例，数据来自 **maps** 包的 unemp 数据集，它有三个变量，fips 城镇代码[^fips]，pop 人口，unemp 失业率。失业率本是连续的数据，将其分级划分区间，每个失业率区间用不同颜色表示。


[^fips]: 可类比我国[行政区划代码](http://www.mca.gov.cn/article/sj/xzqh/1980/)，自1980年以来，每年都会发布一次，涉及一些市、区、县、乡、镇、街道等的变更。


### maps

**maps** 包提供城镇地图数据，数据集 county.fips 各个城镇的名称 polyname 及 行政代码 fips，和 unemp 数据集关联可以知道各个城镇的失业率，再与城镇地图数据关联，就可以将数据绘制在地图上。county.fips 没有夏威夷、阿拉斯加、波多黎各的地图数据，导致 unemp 数据集里阿拉斯加、夏威夷、波多黎各和部分弗吉尼亚的小城市无法映射到地图上。




```{r unemp-maps}
#| fig.cap="2009 年美国各个城镇的失业率分布",
#| fig.width=6*1.5,
#| fig.height=4*1.75,
#| fig.align="center",
#| fig.showtext=TRUE,
#| collapse=TRUE,
#| out.width="75%"

# 代码调整自帮助文档 ?map
library(maps)
library(mapproj)
# 失业率数据
data(unemp)
# 行政编码
data(county.fips)
# 准备调色板
# colors <- c("#F1EEF6", "#D4B9DA", "#C994C7", "#DF65B0", "#DD1C77", "#980043")
colors <- viridisLite::plasma(9)
# 失业率划分区间
unemp$colorBuckets <- as.numeric(cut(unemp$unemp, c(seq(0, 10, by = 2), 15, 20, 25, 100)))
# 准备图例文本
leg.txt <- c("<2%", "2-4%", "4-6%", "6-8%", "8-10%", "10-15%", "15-20%", "20-25%", ">25%")

cnty.fips <- county.fips$fips[match(
  map("county", plot = FALSE)$names,
  county.fips$polyname
)]

# 匹配上的区域
colorsmatched <- unemp$colorBuckets[match(cnty.fips, unemp$fips)]
par(mar = c(1.5, 0, 2, 0))
# 绘制区县地图
map("county",
  col = colors[colorsmatched], fill = TRUE, resolution = 0,
  lty = 0, projection = "polyconic", mar = c(0.5, 0.5, 2, 0.5)
)
# 添加州边界线
map("state",
  col = "white", fill = FALSE, add = TRUE,
  lty = 1, lwd = 0.2, projection = "polyconic"
)
# 添加图标题
title("2009 年美国各个城镇的失业率")
mtext(text = "数据源：美国人口调查局", side = 1, adj = 0)
# 添加图例
legend("top", leg.txt, horiz = TRUE, fill = colors, cex = 0.85)
```

### latticeExtra

```{r unemp-lattice}
#| fig.cap="2009 年美国各个城镇的失业率分布",
#| fig.width=8,
#| fig.height=5,
#| fig.align="center",
#| fig.showtext=TRUE

# 地图数据
us_county <- map("county", plot = FALSE, fill = TRUE, projection = "polyconic")
# 失业率数据和行政区域名称关联
unemp_df <- merge(unemp, county.fips, by = "fips")
# 绘图
latticeExtra::mapplot(polyname ~ unemp,
  data = unemp_df,
  map = us_county,
  colramp = viridisLite::plasma,
  border = NA,
  # cuts = 10, # 等距分桶的数，和参数 breaks 二选一
  breaks = c(seq(0, 10, by = 2), 15, 20, 25, 30, 35),
  subset = polyname %in% us_county$names,
  scales = list(draw = F),
  xlab = "",
  par.settings = list(
    # 副标题放在左下角
    par.sub.text = list(
      font = 2,
      just = "left",
      x = grid::unit(5, "mm"),
      y = grid::unit(5, "mm")
    ),
    # 轴线设置白色以隐藏
    axis.line = list(col = "white")
  ),
  sub = "数据源：美国人口调查局",
  main = "2009 年美国各个城镇的失业率"
)
```


### ggplot2


[**usmapdata**](https://github.com/pdil/usmapdata) 包提供美国国家、州和城镇边界地图数据，下面以此数据为基础，借助 **ggplot2** 包[@Wickham2022]绘制失业率专题地图，未收集到失业率数据的城镇填充灰色，图中中文采用 **showtext** 包[@Qiu2015]处理，如图 \@ref(fig:unemp-ggplot2) 所示。

```{r unemp-ggplot2}
#| fig.cap="2009 年美国各个城镇的失业率分布",
#| fig.width=8,
#| fig.height=6,
#| fig.align="center",
#| fig.showtext=TRUE,
#| echo=FALSE

# 失业率数据和行政编码数据结合
unemp_df <- merge(unemp, county.fips, by = "fips")
# 从 usmapdata 包获取地图数据
county_df <- usmapdata::us_map("counties")
# 行政编码是一串数字组成的字符串
county_df$fips <- as.numeric(county_df$fips)
# 地图数据和失业率数据结合
choropleth <- merge(county_df, unemp_df, by = "fips", all.x = TRUE)
# 还原地图数据的顺序
choropleth <- choropleth[order(choropleth$order), ]
# 失业率分级
choropleth$rate_d <- cut(choropleth$unemp, breaks = c(seq(0, 10, by = 2), 15, 20, 25, 30, 35))
# 准备州边界线数据
state_df <- usmapdata::us_map("states")
# 绘图
library(ggplot2)
ggplot(choropleth, aes(x, y, group = group)) +
  geom_polygon(aes(fill = rate_d), colour = alpha("white", 1 / 4), size = 0.2) +
  geom_polygon(data = state_df, colour = "white", fill = NA, size = 0.3) +
  # scale_fill_brewer(palette = "PuRd", na.value = "grey80") +
  scale_fill_viridis_d(option = "plasma", na.value = "grey80") +
  labs(
    fill = "失业率(%)", title = "2009 年美国各个城镇的失业率",
    caption = "数据源：美国人口调查局"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```


### sf

相比于前任 **sp** 包，**sf** 包将是新一代空间数据操作、分析和可视化的基石，引入 GDAL、PROJ 和 GEOS 三大基础框架，和更庞大的空间数据社区接轨，不局限于 R 语言社区的一亩三分地。**sf** 包支持 Base R 绘图，以此绘制失业率专题地图，如图\@ref(fig:unemp-sf)所示，可见效果丝毫不逊于 **lattice** 和 **ggplot2** 版本，而且在兼容性、代码量、稳定性和性能等方面有明显优势。

```{r unemp-sf}
#| fig.cap="2009 年美国各个城镇的失业率分布",
#| fig.width=8,
#| fig.height=5,
#| fig.align="center",
#| message=FALSE,
#| fig.showtext=TRUE

# 准备地图数据
us_county_shifted <- readRDS(file = "data/us_county_shifted.rds")
# 准备用于合并操作的主键
us_county_shifted <- within(us_county_shifted, {
  polyname <- tolower(paste(STATE_NAME, NAME, sep = ","))
})
# 将失业率数据和地图数据合并
us_county_data <- merge(x = us_county_shifted, y = unemp_df, by = "polyname", all.x = T)
# 绘制失业率地图
plot(us_county_data["unemp"],
  pal = viridisLite::plasma,
  breaks = c(seq(0, 10, by = 2), 15, 20, 25, 30, 35),
  border = NA, key.pos = 4, reset = F,
  main = "2009 年美国各个城镇的失业率"
)
# 添加州边界
plot(st_geometry(us_states_shifted), col = NA, border = "gray", add = T)
mtext(text = "数据源：美国人口调查局", side = 1, adj = 0)
```




## 美国各个城镇的年平均癌症死亡率分布


接下来，以 [**latticeExtra** 包](https://latticeextra.r-forge.r-project.org/)内置的 USCancerRates 数据集为例介绍分面，同时展示多个观测指标的空间分布。USCancerRates 数据集来自美国[National Cancer Institute](https://statecancerprofiles.cancer.gov/)（美国国家癌症研究中心，简称NCI）。根据1999-2003年的5年数据，分男女统计癌症年平均死亡率（单位十万分之一），这其中的癌症数是所有癌症种类之和。不难看出，女性癌症死亡率整体上低于男性，且各个地区的死亡率有明显差异。

<!--
死亡率根据2000年美国[标准人口年龄分组](https://seer.cancer.gov/stdpopulations/stdpop.19ages.html)调整，分母人口数量由NCI根据普查的人口数调整。

一系列复杂的调整是为什么？
指标稳定性，咋一看可能觉得奇怪，本身就是要优化提升指标，你还弄来一个稳定的指标，稳定不是代表不变，稳定是不受轻易干扰。
一致性，时效性，准确性
-->

### latticeExtra

**maps** 包内置的美国城镇地图数据欠缺一部分，导致数据集 USCancerRates 有部分数据没法绘制在地图上，主要是阿拉斯加、夏威夷和其它少量地方，此外，USCancerRates 没有夏威夷、波多黎各各个城镇的数据，阿拉斯加的部分城镇有数据，结合图\@ref(fig:us-cancer-rates-lattice)，不少城镇没有收集到癌症死亡率数据，以空白表示。只需传给参数 `colramp` 一个生成颜色值向量的函数即可更改调色板，比如 R 内置的 `hcl.colors()` 和 `terrain.colors()` 等，为保持全文配色风格一致，图中配色采用 **viridisLite** 包提供的 plasma 调色板。 **lattice** 包提供非常简便的绘图公式语法，**latticeExtra** 也很好地继承了这一特性，`rownames(USCancerRates) ~ rate.female / 100 + rate.male / 100`。`rownames(USCancerRates)` 表示的城镇名称和地图数据 `us_county` 里的城镇名称 names 是可以映射上的。值得一提的是，关于死亡率分级，不同的分法会带给人不同的印象甚至是错觉，此处是可以做手脚的，特定的死亡率分割方式可以让男女死亡率的空间分布**看起来**差异不大或很大。


```{r us-cancer-rates-lattice}
#| fig.cap="美国各个城镇的癌症死亡率分布",
#| fig.width=8,
#| fig.height=10,
#| fig.align="center",
#| fig.showtext=TRUE

library(maps)
library(lattice)
# 加载数据
data(USCancerRates, package = "latticeExtra")
# 绘图
latticeExtra::mapplot(rownames(USCancerRates) ~ rate.female / 100 + rate.male / 100,
  # 数据
  data = USCancerRates,
  # 城镇地图数据为背景
  map = us_county,
  # 填充地图用的调色板
  colramp = viridisLite::plasma,
  # 城镇边界线
  border = NA,
  # 多图布局 1 列 2 行
  layout = c(1, 2),
  # 死亡率分桶数
  # cuts = 14, # 指定 breaks 后就不需要 cuts
  # 死亡率数据分割点
  breaks = seq(from = 0, to = 6.5, by = 0.5),
  # 仅展示地图数据中包含的城镇死亡率数据
  subset = rownames(USCancerRates) %in% us_county$names,
  # 取消坐标轴刻度
  scales = list(draw = F),
  # 修改分面展示文本
  strip = strip.custom(factor.levels = c("女性", "男性")),
  xlab = "",
  # 添加图例标题
  legend = list(top = list(
    fun = grid::textGrob("死亡率(‰)", y = 0.1, x = 1.03)
  )),
  # 常规图形参数列表 trellis.par.get('par.sub.text')
  par.settings = list(
    # 副标题放在左下角
    par.sub.text = list(
      font = 2,
      just = "left",
      x = grid::unit(5, "mm"),
      y = grid::unit(5, "mm")
    ),
    # 分面边界和背景色
    strip.border = list(col = "white"),
    strip.background = list(col = "white"),
    # 轴线设置白色以隐藏
    axis.line = list(col = "white")
  ),
  # 副标题
  sub = "数据源：美国国家癌症研究所",
  # 主标题
  main = "1999 年至 2003 年美国各个城镇的年平均癌症死亡率"
)
```

<!-- 
颜色变量的分级，等距分割，分位点分割
https://makosak.github.io/Intro2RSpatialMed/02-choropleth.html

如何修改 strip names
https://stackoverflow.com/questions/7373487/change-text-on-strips-in-lattice-plots 
par.settings 图形参数设置
https://www.magesblog.com/post/2015-06-16-how-to-place-titles-in-lattice-plots/
par.sub.text 所有可调整的参数及其含义
trellis.par.get('par.sub.text')

-->


**lattice** 包[@Sarkar2008]可以提供精细化的图形操作，如图 \@ref(fig:show-settings) 所示

```{r show-settings}
#| fig.cap="图形控制参数",
#| fig.width=9,
#| fig.height=6,
#| fig.align="center"

library(lattice)
show.settings()
```


```{r trellis-par}
#| fig.cap="lattice 常用图形参数小抄",
#| fig.width=6,
#| fig.height=8,
#| fig.align="center",
#| echo=FALSE,
#| fig.showtext=TRUE

# 修改自帮助文档 ?trellis.par.get()
tp <- trellis.par.get()
# 去掉不常用的参数设置
unusual <- c(
  "grid.pars", "fontsize", "clip", "axis.components",
  "layout.heights", "layout.widths"
)
tp[names(tp) %in% unusual] <- NULL
# 抽取 pars 中的参数名称
extract_names <- function(name, pars) {
  expand.grid(x = name, y = names(`[[`(pars, name)), z1 = 1)
}
# 抽取结果保存为 data.frame
dat1 <- do.call("rbind", lapply(names(tp), FUN = extract_names, pars = tp))
# 初始化数据框
dat2 <- data.frame(
  expand.grid(x = levels(dat1$x), y = levels(dat1$y)),
  z2 = 0
)
# 填充数据框
dat <- merge(x = dat2, y = dat1, by = c("x", "y"), all.x = T)
dat <- within(dat, {
  z <- z1 | z2
})

# 绘图
levelplot(z ~ y * x,
  data = dat, scales = list(
    draw = T,
    # 去掉图形上边、右边多余的刻度线
    x = list(rot = 45, alternating = 1, tck = c(1, 0)),
    y = list(alternating = 1, tck = c(1, 0))
  ),
  xlab = "设置名称", ylab = "图形参数", colorkey = FALSE,
  panel = function(x, y, z, ...) {
    panel.abline(
      v = unique(as.numeric(x)),
      h = unique(as.numeric(y)),
      col = "grey"
    )
    panel.xyplot(x, y, pch = 16 * z, ...)
  }
)
```



### ggplot2

考虑到 **maps** 包内置的地图数据的缺陷，**ggplot2** 包的流行度，下面采用 **ggplot2** 包绘制分面专题地图，相比于 **latticeExtra** 包，**ggplot2** 包更适合「长格式」的数据，因此，先重塑 USCancerRates 数据集，对性别和死亡率字段做一些处理，城镇死亡率数据和城镇地理边界数据配对，再根据死亡率的分布设置合适分段，最后恢复地图数据的原始顺序。

USCancerRates 数据集除了 state 和 county 列，剩余列是由三个原子指标按性别维度衍生出来的，分别是癌症死亡率及其置信区间的上、下限值。在「宽格式」转「长格式」过程中，要注意转化前后各个列名的对应关系，后面会着重介绍一下。


```{r}
# 宽格式转长格式
us_cancer_rates <- reshape(
  data = USCancerRates,
  # 需要转行的列，也可以用列序号代替
  varying = c(
    "LCL95.male", "rate.male", "UCL95.male",
    "LCL95.female", "rate.female", "UCL95.female"
  ),
  times = c("男性", "女性"), # 构成新列 sex 的列值
  v.names = c("LCL95", "rate", "UCL95"), # 列转行 列值构成的新列，指定名称
  timevar = "sex", # 列转行 列名构成的新列，指定名称
  idvar = c("state", "county"), # 可识别城镇的编码
  # 原数据有 3041 行，性别字段只有两个取值，转长格式后有 2*3041 行
  new.row.names = 1:(2 * 3041),
  direction = "long"
)
# 性别字段重编码，死亡率单位从十万分之一转为千分之一
us_cancer_rates <- within(us_cancer_rates, {
  rate <- rate / 100
  LCL95 <- LCL95 / 100
  UCL95 <- UCL95 / 100
})
# 给每个城镇的癌症死亡率数据配上地图数据
dat <- merge(county_df, us_cancer_rates, by.x = c("full", "county"), by.y = c("state", "county"), all.y = T)
# 癌症死亡率分级
# dat$rate_d <- cut(dat$rate, breaks = c(0, 0.50, 1.00, 1.50, 2.00, 2.50, 3.00, 4.50, 6.00, 7.50))
dat$rate_d <- cut(dat$rate, breaks = seq(from = 0, to = 6.5, by = 0.5))
# 恢复地图数据顺序
dat <- dat[order(dat$order), ]
```

关于数据操作，在不影响效率的情况下，笔者会优先选择 Base R 来做数据操作，若遇到小规模数据会考虑调用 data.table 来处理，若遇到大规模数据肯定是用 SQL 来处理，聚合完继续用 Base R 或 data.table 处理。工作几年下来，任凭窗外云卷云舒，在稳定和效率面前，我自岿然不动，笔者看过不少净土代码，也写过一些，所知有限，不敢示人，常晓其大意，换之以 Base R。


处理数百 GB 乃至 TB 级的海量数据，聚合计算通常都是由写 SQL 完成的，不太可能直接用 R 语言或 Python 语言去处理，什么牛逼的工具包都不行！SQL 聚合计算后得到的数据集就 KB 或 MB级，大约几千，几万或几十万，即使遇到几百万条记录，也是用 SQL 再按需聚合。只在最后，为了可视化和分析建模，对 SQL 查询后的数据做各种适应性变换，这其中变形重塑的数据操作是最常见的，也是最复杂的数据操作，并且在SQL中实现复杂而在R中非常简单。用户唯一的痛点是非常难记住 reshape 的到底是谁，长变宽还是宽变长。从 `reshape()` 函数到 **reshape** 包，再到 **reshape2** 包，再到 **tidyr** 包，一路折腾，笔者认为还是应该回归到出发点来看待 `reshape()` 函数。


R 软件内置的函数 `reshape()` 有很丰富的解释。所谓的「宽格式」和「长格式」数据来源于纵向数据分析领域 longitudinal data analysis --- 对同一对象的同一特征在不同时间点重复测量分析（假定对象没有随时间发生变化），也可以是对多个特征在不同时间点重复测量，这些特征就是所谓的时间变量 timevar（time-varying variables），有的特征随时间不会变化，比如性别、种族等，称之为时间常量 （time-constant variables）。函数 `reshape()` 的参数就采用纵向数据分析的术语。


大部分的数据可视化和统计建模函数要求长格式的数据，所以，从宽格式到长格式是更常见的变形操作。以上对数据集 USCancerRates 从宽格式到长格式的变形操作是非常典型的，读者可对照帮助文档 `?reshape()` 和如下两种方式理解其他传参方式对结果的影响，以加深对变形操作的理解。

```r
# 方式二
reshape(
  data = USCancerRates,
  varying = list(
    LCL95 = c("LCL95.male", "LCL95.female"),
    rate = c("rate.male", "rate.female"),
    UCL95 = c("UCL95.male", "UCL95.female")
  ),
  times = c("男性", "女性"), # 可选，最好填
  v.names = c("LCL95", "rate", "UCL95"), # 可选，最好填
  timevar = "sex", # 可选，最好填
  idvar = c("state", "county"), # 必填
  new.row.names = 1:(2 * 3041), # 可选，最好填
  direction = "long"
)
# 方式三
reshape(
  data = USCancerRates,
  varying = list(
    LCL95 = c("LCL95.male", "LCL95.female"),
    rate = c("rate.male", "rate.female"),
    UCL95 = c("UCL95.male", "UCL95.female")
  ),
  # times = c("男性", "女性"),
  # v.names = c("LCL95", "rate", "UCL95"),
  timevar = "sex",
  idvar = c("state", "county"),
  new.row.names = 1:(2 * 3041),
  direction = "long"
)
```

数据准备工作完成后，除了在细节上不断试错外，绘图过程主要有七个步骤：

1. 绘制美国城镇地图，填充灰色背景，以此为底图。
1. 添加每个城镇的癌症死亡率数据，填充颜色根据死亡率而定，以浅白色绘制城镇的边界线，且将线调细一些，与后面州的边界线形成层次。
1. 添加美国各个州的边界线，帮助熟悉美国地图的从州到城镇快速定位。
1. 类似前文设置，采用 `plasma` 调色板，未采集到死亡率数据的城镇填充灰色，和地图背景融为一体。
1. 以函数 `facet_wrap()` 实现分面，分面标题放在图形下方，布局为一列两行。
1. 添加整个图形的主标题、副标题和图例标题。
1. 设置整个图形主题样式 `theme_void()` 以符合专题地图特色，将图形主标题居中。

```{r us-cancer-rates-ggplot2}
#| fig.cap="1999 年至 2003 年美国各个城镇的年平均癌症死亡率分布",
#| fig.width=8,
#| fig.height=10,
#| fig.align="center",
#| fig.showtext=TRUE

ggplot() +
  geom_polygon(data = county_df, aes(x, y, group = group), fill = "grey80") +
  geom_polygon(data = dat, aes(x, y, group = group, fill = rate_d), colour = alpha("white", 1 / 4), size = 0.2) +
  geom_polygon(data = state_df, aes(x, y, group = group), colour = "white", fill = NA, size = 0.3) +
  scale_fill_viridis_d(option = "plasma", na.value = "grey80") +
  facet_wrap(~sex, ncol = 1, strip.position = "bottom") +
  labs(
    fill = "死亡率(‰)", title = "1999 年至 2003 年美国各个城镇的年平均癌症死亡率",
    caption = "数据源：美国国家癌症研究所"
  ) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5))
```


**lattice** 包绘制图形，常常以层层嵌套的列表传递给参数来实现局部细节调整，这和一些基于 JavaScripts 的数据可视化库是不谋而合，前者是 R 中的 list 对象，后者往往是一些 JSON 格式或键值对形式的数据对象。关键点是纵向的层次性和横向的互斥性，同层互斥不同层正交，稳扎稳打，不至于牵一发而动全身。


**ggplot2** 绘图的理论基础是图形语法，将数据和几何元素建立映射关系，几何和统计图层层层叠加实现主体部分，辅以字体、颜色、坐标系、布局等实现精细调整，达到出版级的效果。图层的精妙之处在于符合 Unix 哲学 --- Do one thing, and do it well! 上面将整个复杂的图形拆解为一张张图层，每个图层干一件事，将复杂的过程简化下来。至于具体到地图，因涉及到地图数据，情况稍微复杂一些，需要考虑地图数据和观测数据的坐标参考系，点、线、面（多边形或区域）数据类型，以及属于矢量还是栅格数据。总而言之，画个图，看似简单其实也透着综合能力，复杂过程的拆解能力，软件工具的熟练程度，领域知识的了解深度，难以言表的审美能力。



```{r}
qnorm(p = 1 - 0.05 / 2)
head(us_cancer_rates)
```

Alabama 的 Pickens County 为例，死亡率为，在 95% 置信水平下，区间上下限关于统计值对称，则

$$
\begin{align}
3.111 = 3.637 - 1.96*x \\
3.637 + 1.96*x = 4.232
\end{align}
$$

癌症死亡率，及其波动情况，一个地区的平均死亡率 660 人，波动很大，意味着该地区不同地方的死亡率差别很大。

LCL95 和 UCL95 是怎么计算的？需要研究和说明一下，从美国国家癌症研究所了解一下


### tmap

同 **sf** 包[@Pebesma2018]的绘图函数 `plot()` 一样，**tmap** [@Tennekes2018] 也是基于 Base R 图形系统，但使用语法更加贴合 **ggplot2** 包[@Wickham2022]，对空间数据可视化有更多专业支持，比如比例符号图[@Susumu2006]。

```{r us-cancer-rates-tmap}
#| fig.cap="1999-2003 年美国各个城镇的年平均癌症死亡率分布",
#| fig.width=8,
#| fig.height=10,
#| fig.align="center",
#| fig.showtext=TRUE

us_county_cancer2 <- merge(
  x = us_county_shifted, y = us_cancer_rates,
  by.x = c("STATE_NAME", "NAMELSAD"),
  by.y = c("state", "county"), all.x = TRUE
)

tmap::tm_shape(us_county_cancer2) +
  tmap::tm_polygons(border.col = "gray") +
  tmap::tm_shape(us_county_cancer2) +
  tmap::tm_polygons(
    col = "rate",
    palette = "plasma", border.alpha = 0.2,
    legend.reverse = TRUE, title = "死亡率(‰)",
    colorNA = "gray",
    textNA = "NA", border.col = "gray",
    breaks = seq(from = 0, to = 6.5, by = 0.5)
  ) +
  tmap::tm_facets(by = "sex", drop.NA.facets = T, ncol = 1) +
  tmap::tm_shape(us_states_shifted) +
  tmap::tm_polygons(col = NA, border.col = "gray", alpha = 0) +
  tmap::tm_compass(position = c("right", "bottom")) +
  tmap::tm_scale_bar(position = c("right", "bottom")) +
  tmap::tm_credits(text = "数据源：美国国家癌症研究所", position = "left") +
  tmap::tm_layout(
    legend.outside = TRUE,
    legend.outside.position = "right",
    legend.outside.size = 0.15,
    outer.margins = 0, 
    asp = 0
  )
```


### sf

```{r us-cancer-rates-sf}
#| fig.cap="1999-2003 年美国各个城镇的年平均癌症死亡率分布",
#| fig.width=8,
#| fig.height=5,
#| fig.align="center",
#| fig.showtext=TRUE

# 空间数据合并观测数据
us_county_cancer <- merge(
  x = us_county_shifted, y = USCancerRates,
  by.x = c("STATE_NAME", "NAMELSAD"),
  by.y = c("state", "county"), all.x = TRUE
)
# 绘图数据
plot(us_county_cancer["rate.male"],
  pal = viridisLite::plasma, reset = FALSE,
  breaks = seq(from = 0, to = 6.5, by = 0.5) * 100,
  border = "gray", lwd = 0.25, main = "男性", key.pos = 4
)
plot(st_geometry(us_states_shifted), border = "gray80", add = TRUE)
mtext(text = "数据源：美国人口调查局", side = 1, adj = 0)
plot(us_county_cancer["rate.female"],
  pal = viridisLite::plasma, reset = FALSE,
  breaks = seq(from = 0, to = 6.5, by = 0.5) * 100,
  border = "gray", lwd = 0.25, main = "女性", key.pos = 4
)
plot(st_geometry(us_states_shifted), border = "gray80", add = TRUE)
mtext(text = "数据源：美国人口调查局", side = 1, adj = 0)
```

### mapsf

**mapsf** 包 [@mapsf2022] 在 sf 包的基础上添加更多地理可视化的功能，比如指北针、比例尺等。

```{r us-cancer-rates-mapsf}
#| fig.cap="1999-2003 年美国各个城镇的年平均癌症死亡率分布",
#| fig.width=9,
#| fig.height=6,
#| fig.align="center",
#| fig.showtext=TRUE

library(mapsf)
# 设置主题
mf_theme("default", inner = TRUE, tab = TRUE, pos = "center")
# 绘制地图
mf_map(
  x = us_county_cancer, 
  var = "rate.male",
  type = "choro",
  breaks = seq(from = 0, to = 6.5, by = 0.5) * 100,
  pal = "Plasma",
  border = "gray", 
  lwd = 0.5,
  leg_val_rnd = 0,
  leg_pos = "left", 
  leg_no_data = "缺失",
  leg_title = "死亡率\n(每10万人)"
) 
# 指北箭头
mf_arrow(pos = "topleft")
# 比例尺
mf_scale(pos = "bottomleft")
# 标题
mf_title(txt = "男性", bg = "#f7f7f7", fg = "black")
# 出处
mf_credits(txt = "数据源：美国人口调查局", pos = "bottomright")

mf_map(
  x = us_county_cancer, 
  var = "rate.female",
  type = "choro",
  breaks = seq(from = 0, to = 6.5, by = 0.5) * 100,
  pal = "Plasma",
  border = "gray", 
  lwd = 0.5,
  leg_val_rnd = 0,
  leg_pos = "left", 
  leg_no_data = "缺失",
  leg_title = "死亡率\n(每10万人)"
) 
mf_arrow(pos = "topleft")
mf_scale(pos = "bottomleft")
mf_title(txt = "女性", bg = "#f7f7f7", fg = "black")
mf_credits(txt = "数据源：美国人口调查局", pos = "bottomright")
```

::: rmdnote
**mapsf** 包函数 `mf_map()` 的参数 `pal` 取自 R 内置的调色板 `hcl.pals()`，内部函数 `mapsf:::get_the_pal()` 将调色板反向了。
:::

# 多变量情形


[多元专题地图](https://en.wikipedia.org/wiki/Multivariate_map)用以同时展示两个具有空间相关性的变量，比如人均收入和平均寿命，房地产投资占比和城镇化率[@Meyer1975]。下面以美国各州人均收入和平均寿命为例，在专题地图上同时展示多个指标，除了用到 **ggplot2** 和 **sf** 包，另外还需 [**biscale**](https://github.com/slu-openGIS/biscale) 和 [**cowplot**](https://github.com/wilkelab/cowplot) 两个包，前者构造多元变量分组，后者负责将图例和地图主体合并。R 社区最早的技术实现方案来自 Timo Grossenbacher 的博客[Bivariate maps with ggplot2 and sf](https://timogrossenbacher.ch/2019/04/bivariate-maps-with-ggplot2-and-sf/)。


## 美国北卡州家庭收入中位数与白人占比的空间相关性

数据集来自 2015-2019 年度美国社区调查 American Community Survey，北卡罗来纳州家庭收入中位数和白人居民的百分比，社区普查粒度（大致相当于按乡镇、街道统计），如图\@ref(fig:bivar-us-states)所示，原始数据可从借助 **tidycensus** 包下载美国官方数据。

Kyle Walker 开发的[**tidycensus**](https://github.com/walkerke/tidycensus) 包制作了 US Census Bureau 美国人口调查局的数据 API 的 R 接口。读者需要先注册一个访问令牌，保存到 R 环境变量 `CENSUS_API_KEY`，以便后续调用。下面主要介绍 `get_decennial()` 可以获取 10 年一次的人口普查数据。

在 .Renviron 文件中存储环境变量 `CENSUS_API_KEY`

### sf

2015-2019年度美国北卡罗来纳州普查级家庭收入中位数的空间分布，数据来自美国人口调查局。

```{r}
#| eval=FALSE
# 加载收入数据
load(file = "data/nc_race_income.RData")
# 地图数据
us_nc_tract <- readRDS(file = "data/us_nc_tract.rds")
# 合并地图数据和收入数据
us_nc_tract_2019 <- merge(x = us_nc_tract, y = nc_tract_race_income, by = "GEOID")
# 收入和白人占比数据
us_nc_tract_2019 <- within(us_nc_tract_2019, {
  pctWhite <- B02001_002E / B02001_001E
  medInc <- B19013_001E
})
# 收入分布
plot(us_nc_tract_2019["medInc"],
  pal = viridisLite::plasma,
  breaks = c(seq(0, 10, 1), 15, 20, 25) * 10000,
  border = "gray", main = "", lwd = 0.25
)
# 区县边界
plot(st_geometry(nc_county_map), border = "white")
```


![(\#fig:us-nc-income) 美国北卡普查收入](img/us-nc-income.png){.full}


### ggplot2 + sf


```{r bivar-us-states}
#| fig.cap="北卡罗来纳州各乡镇收入与白人占比的空间分布",
#| fig.width=6*1.5,
#| fig.height=2.5*1.5,
#| fig.align="center",
#| fig.showtext=TRUE,
#| message=FALSE
# 加载白人占比、收入数据
load(file = "data/nc_race_income.RData")
library(sf) # 县级的地图数据
# 读取数据，且读取后不要转化为 tibble 数据类型
nc_county_map <- read_sf(system.file("gpkg/nc.gpkg", package = "sf"), as_tibble = FALSE)
# 县级地图数据和 ACS 调查数据合并
nc_county_data <- merge(x = nc_county_map, y = nc_county_race_income, by.x = "FIPS", by.y = "GEOID")
# 统计白人占比和收入
nc_county_data <- within(nc_county_data, {
  pctWhite <- B02001_002E / B02001_001E
  medInc <- B19013_001E
})

library(ggplot2)
library(biscale)
library(cowplot)
# 数据分类
nc_bi_data <- bi_class(nc_county_data, x = pctWhite, y = medInc, style = "quantile", dim = 3)
# 创建地图
nc_bi_map <- ggplot(data = nc_bi_data, aes(fill = bi_class)) +
  geom_sf(
    color = "white", size = 0.1, show.legend = FALSE
  ) +
  bi_scale_fill(pal = "DkViolet", dim = 3) +
  labs(title = "北卡罗来纳州收入水平和白人占比的空间相关性") +
  theme_void()
# 创建图例数据
nc_bi_leg_data <- data.frame(expand.grid(x = 3:1, y = 3:1),
  bi_fill = biscale:::pal_dkviolet(n = 3)
)
# 创建图例
nc_bi_leg <- ggplot(data = nc_bi_leg_data, aes(x = x, y = y, fill = bi_fill)) +
  geom_tile() +
  scale_fill_identity() +
  labs(
    x = substitute(paste("白人占比", "" %->% "")),
    y = substitute(paste("收入水平", "" %->% ""))
  ) +
  coord_fixed() +
  theme_void() +
  theme(
    axis.title = element_text(size = 7),
    axis.title.y = element_text(angle = 90)
  )
# 组合地图和图例
ggdraw() +
  draw_plot(nc_bi_map, x = 0, y = 0, width = 1, height = 1) +
  draw_plot(nc_bi_leg, x = 0.1, y = .1, width = 0.2, height = 0.2)
```




# 应用案例


以 2022-03-05 至 2022-03-11 美国新冠日均感染率（单位十万分之一）为例，如图\@ref(fig:us-covid-cases) 所示，图片截自[纽约时报网站](https://www.nytimes.com/interactive/2021/us/covid-cases.html)。


![(\#fig:us-covid-cases) 美国各个城镇新冠感染率，单位十万分之一](img/us-covid-cases.png){.full}


# 本文小结


- 静态版

[ggspatial](https://github.com/paleolimbot/ggspatial) 补充 ggplot2，并没有解决地图变形的核心问题。
[tmap](https://github.com/r-tmap/tmap) 类似 [mapsf](https://github.com/riatelab/mapsf)，相比而言，上游依赖很多，相应功能也多，但绘图性能很差。sp 已是上一代产品，现有工具足以替代，不再介绍。


- 交互版

leaflet/mapdeck/plotly/echarts4r 等交互式图形包不在本文探讨范围，可另外写一篇介绍数据产品，比如面向网页输出的可重复性文档，沉浸式探索性的数据产品



# 环境信息

在 RStudio IDE 内编辑本文的 R Markdown 源文件，用 **blogdown** 构建网站，[Hugo](https://github.com/gohugoio/hugo) 渲染 knitr 之后的 Markdown 文件，得益于 **blogdown** 对 R Markdown 格式的支持，图、表和参考文献的交叉引用非常方便，省了不少文字编辑功夫。文中使用了多个 R 包，为方便复现本文内容，下面列出详细的环境信息：

```{r, message=FALSE}
xfun::session_info(packages = c(
  "knitr", "rmarkdown", "blogdown",
  "ggplot2", "cowplot", "biscale", 
  "lattice", "latticeExtra",
  "maps", "sf", "tidycensus", "tigris"
), dependencies = FALSE)
```


# 参考文献
